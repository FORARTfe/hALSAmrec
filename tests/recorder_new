#!/bin/sh
#
# Original script by J. Bruce Fields, 2024
# This version by FORART (https://forart.it/), 2025
# Optimized for OpenWRT performance
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

readonly MNT=/tmp/mnt
readonly SLEEP_INTERVAL=5
readonly MIN_SPACE_MB=100

# Global state variables
recorder=""
cached_card=""
cached_disk=""
audio_params_cached=""

# Cache for audio device parameters
inputhw=""
max_channels=""
bitformat=""
max_rate=""
buffer_time_max=""
buffer_size_max=""

trap 'true' SIGHUP

sleep infinity &
dummy=$!

trap '	kill $dummy 2>/dev/null;
	[ -n "$recorder" ] && kill $recorder 2>/dev/null;
	umount -l "$MNT" 2>/dev/null;
	exit'	SIGTERM

# Optimized audio card detection with caching
get_audio_card() {
	local current_card
	current_card=$(arecord -l 2>/dev/null | grep -m1 '^card')
	
	# Return cached result if unchanged
	if [ "$current_card" = "$cached_card" ] && [ -n "$cached_card" ]; then
		return 0
	fi
	
	cached_card="$current_card"
	[ -n "$current_card" ]
}

# Ultra-fast disk detection without lsblk - multiple optimization methods
get_exfat_disk() {
	local current_disks count device part fs_type
	
	# Method 1: Check /proc/mounts for already mounted exfat (fastest - pure /proc)
	current_disks=$(awk '$3=="exfat" && $1~/^\/dev\//{print $1; exit}' /proc/mounts 2>/dev/null)
	
	# Method 2: If no mounted exfat, use hotplug events cache (OpenWRT specific)
	if [ -z "$current_disks" ] && [ -d "/tmp/block" ]; then
		for device in /tmp/block/sd* 2>/dev/null; do
			[ -e "$device" ] || continue
			if grep -q 'exfat' "$device" 2>/dev/null; then
				current_disks="/dev/$(basename "$device")"
				break
			fi
		done
	fi
	
	# Method 3: Fast /sys scan only for removable devices (no external commands)
	if [ -z "$current_disks" ]; then
		for device in /sys/block/sd*/removable 2>/dev/null; do
			[ -e "$device" ] || continue
			[ "$(cat "$device" 2>/dev/null)" = "1" ] || continue
			
			device=${device%/removable}
			device=${device##*/}
			
			# Check partitions using /sys filesystem info
			for part in /sys/block/$device/$device*[0-9] 2>/dev/null; do
				[ -e "$part" ] || continue
				part=${part##*/}
				
				# Try to read filesystem info from /sys first (no blkid call)
				if [ -e "/sys/block/${part%[0-9]*}/$part/uevent" ]; then
					if grep -q 'exfat' "/sys/block/${part%[0-9]*}/$part/uevent" 2>/dev/null; then
						current_disks="/dev/$part"
						break 2
					fi
				fi
				
				# Fallback: minimal blkid call only when needed
				if blkid "/dev/$part" 2>/dev/null | grep -q 'TYPE="exfat"'; then
					current_disks="/dev/$part"
					break 2
				fi
			done
		done
	fi
	
	# Simple existence and cache check
	if [ -n "$current_disks" ] && [ -e "$current_disks" ]; then
		if [ "$current_disks" = "$cached_disk" ]; then
			return 0
		fi
		cached_disk="$current_disks"
		return 0
	fi
	
	cached_disk=""
	return 1
}

# Probe audio parameters only once per device
probe_audio_params() {
	local device_info card device arecord_output
	
	# Skip if already cached for current card
	[ -n "$audio_params_cached" ] && [ "$audio_params_cached" = "$cached_card" ] && return 0
	
	device_info=$(arecord -l 2>/dev/null | grep -A 2 "List of CAPTURE Hardware Devices" | grep -A 1 "card [0-9]:" | head -n 3)
	card=$(printf '%s\n' "$device_info" | grep "card [0-9]:" | sed -E 's/.*card ([0-9]+):.*/\1/')
	device=$(printf '%s\n' "$device_info" | grep "device [0-9]:" | sed -E 's/.*device ([0-9]+):.*/\1/')
	
	[ -z "$card" ] && return 1
	
	inputhw="$card,$device"
	arecord_output=$(arecord -D "hw:$inputhw" --dump-hw-params 2>&1)
	
	# Extract parameters efficiently
	max_channels=$(printf '%s\n' "$arecord_output" | sed -n '/CHANNELS:/{s/.*CHANNELS: \[\?\([0-9]*\)\( \([0-9]*\)\)\?\]/\3/p;t;s/.*CHANNELS: \([0-9]*\)/\1/p;}')
	
	bitformat=$(printf '%s\n' "$arecord_output" | sed -n '/^FORMAT:/{s/.*FORMAT: \(.*\)/\1/p;s/.* \([A-Z0-9_]*\)/\1/p;}' | tail -1)
	
	max_rate=$(printf '%s\n' "$arecord_output" | sed -n '/RATE:/{s/.*[\[(]\([0-9]*\) \([0-9]*\)[])].*/\2/p;t;s/.*RATE: \([0-9]*\)/\1/p;}')
	
	buffer_time_max=$(printf '%s\n' "$arecord_output" | sed -n '/BUFFER_TIME:/ s/.*[\[(]\([0-9]*\) \([0-9]*\)[])].*/\2/p')
	buffer_size_max=$(printf '%s\n' "$arecord_output" | sed -n '/BUFFER_SIZE:/ s/.*[\[(]\([0-9]*\) \([0-9]*\)[])].*/\2/p')
	
	# Cap rate at 48kHz for performance
	[ "$max_rate" -gt 48000 ] && max_rate=48000
	
	audio_params_cached="$cached_card"
	return 0
}

# Efficient disk space check
check_disk_space() {
	local avail_kb
	avail_kb=$(df -k "$MNT" 2>/dev/null | awk 'NR==2 {print $4}')
	[ -n "$avail_kb" ] && [ $((avail_kb / 1024)) -gt $MIN_SPACE_MB ]
}

# Process cleanup
cleanup_recorder() {
	if [ -n "$recorder" ] && ! kill -0 "$recorder" 2>/dev/null; then
		recorder=""
		umount -l "$MNT" 2>/dev/null
		return 0
	fi
	return 1
}

# Optimized unique filename generation
generate_filename() {
	local name logfile
	name=$(date +%s)
	logfile="$MNT/${name}.log"
	
	# Quick check for uniqueness
	while [ -e "$logfile" ]; do
		name=$((name + 1))
		logfile="$MNT/${name}.log"
	done
	
	printf '%s' "${name}_${max_channels}-${max_rate}-${bitformat}"
}

# Main recording function
start_recording() {
	local filename
	
	# Create mount point only when needed
	[ ! -d "$MNT" ] && mkdir -p "$MNT"
	
	# Mount with optimizations for flash storage
	mount -o noatime,nodiratime "$cached_disk" "$MNT" || return 1
	
	# Check space before starting
	check_disk_space || {
		umount -l "$MNT" 2>/dev/null
		return 1
	}
	
	# Generate filename
	filename=$(generate_filename)
	
	# Start recording with optimized parameters
	arecord --device=hw:${inputhw} \
		--channels=${max_channels} \
		--file-type=raw \
		--format=${bitformat} \
		--rate=${max_rate} \
		--buffer-time=${buffer_time_max} \
		--buffer-size=${buffer_size_max} \
		> "${MNT}/${filename}.raw" 2>/dev/null &
	
	recorder=$!
}

# Main loop
first=1
while true; do
	if [ "$first" -eq 1 ]; then
		first=0
	else
		# Efficient wait with timeout
		if [ -n "$recorder" ]; then
			wait $recorder
		else
			sleep $SLEEP_INTERVAL
		fi
	fi
	
	# Check if recorder process died
	cleanup_recorder
	
	# Quick checks with caching
	get_audio_card && get_exfat_disk && [ -e "$cached_disk" ]
	ready=$?
	
	if [ $ready -ne 0 ]; then
		if [ -n "$recorder" ]; then
			kill -TERM "$recorder" 2>/dev/null
			sleep 1
			kill -KILL "$recorder" 2>/dev/null
			recorder=""
			umount -l "$MNT" 2>/dev/null
			# Clear cache on disconnect
			cached_card=""
			cached_disk=""
			audio_params_cached=""
		fi
		continue
	fi
	
	# Skip if already recording
	[ -n "$recorder" ] && continue
	
	# Probe audio parameters (cached)
	probe_audio_params || continue
	
	# Start recording
	start_recording
done
